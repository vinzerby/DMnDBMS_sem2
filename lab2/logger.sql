CREATE TABLE LOGS (
	ID NUMBER PRIMARY KEY,
	TABLE_NAME VARCHAR2(64) NOT NULL,
	OPERATION_TYPE VARCHAR2(16) NOT NULL,
	LOG_TIMESTAMP TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
	ID_OLD NUMBER,
	ID_NEW NUMBER,
	NAME_OLD VARCHAR2(256),
	NAME_NEW VARCHAR2(256),
	NUMB_FIELD_OLD NUMBER,
	NUMB_FIELD_NEW NUMBER);

CREATE SEQUENCE LOGS_ID_SEQ
	START WITH 1
	INCREMENT BY 1
	NOCACHE;

CREATE OR REPLACE TRIGGER LOGS_ID_TRIGGER
BEFORE INSERT ON LOGS
FOR EACH ROW
BEGIN
	SELECT LOGS_ID_SEQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


-- In order to change DB state to timestamp log state, we need to reverse all changes as follows:
-- Insert -> Delete
-- Delete -> Insert
-- Update from old to new -> Update from new to old

CREATE OR REPLACE PROCEDURE RESTORE_BY_LOGS(RESTORE_TIME TIMESTAMP)
IS
BEGIN
	DBMS_OUTPUT.PUT_LINE('Inside restoring logs procedure!!! ');
	IF FLAGS.IS_JUMPED_TO_TIMESTAMP THEN
		DBMS_OUTPUT.PUT_LINE('DB is already at the state of  ' || FLAGS.JUMPED_TIMESTAMP);

	ELSE
		DBMS_OUTPUT.PUT_LINE('Jumping to timestamp!!! ' || RESTORE_TIME);
		FLAGS.JUMPED_TIMESTAMP := RESTORE_TIME;
		FLAGS.IS_JUMPED_TO_TIMESTAMP := TRUE;
	
		DBMS_OUTPUT.PUT_LINE('Restoring logs up to date ');
		FLAGS.IS_RESTORING_TABLES_BY_LOG := TRUE;
	
	
		FOR LOG IN ( SELECT * FROM LOGS WHERE LOG_TIMESTAMP >= RESTORE_TIME ORDER BY LOG_TIMESTAMP DESC)
		LOOP
			DBMS_OUTPUT.PUT_LINE(' ');
			DBMS_OUTPUT.PUT_LINE('Working on log with id = ' || LOG.ID);
			IF LOG.TABLE_NAME = 'STUDENTS' THEN
				DBMS_OUTPUT.PUT_LINE('Working with STUDENTS record!!! ');

				IF LOG.OPERATION_TYPE = 'INSERT' THEN
					-- Backdate insertion
					DELETE FROM STUDENTS WHERE ID = LOG.ID_NEW;
					DBMS_OUTPUT.PUT_LINE('Deleted student with id = ' || LOG.ID_NEW);
				
				ELSIF LOG.OPERATION_TYPE = 'UPDATE' THEN
					-- Backdate update
					UPDATE STUDENTS 
					SET ID = LOG.ID_OLD, NAME = LOG.NAME_OLD, GROUP_ID = LOG.NUMB_FIELD_OLD
					WHERE ID = LOG.ID_NEW;
				
					DBMS_OUTPUT.PUT_LINE('Updated student with id = ' || LOG.ID_NEW);

				
				ELSIF LOG.OPERATION_TYPE = 'DELETE' THEN
					-- Backdate deletion
					INSERT INTO STUDENTS VALUES (LOG.ID_OLD, LOG.NAME_OLD, LOG.NUMB_FIELD_OLD);
					DBMS_OUTPUT.PUT_LINE('Inserted student with id = ' || LOG.ID_OLD);
				END IF;
			
			ELSIF LOG.TABLE_NAME = 'GROUPS' THEN
			
				IF LOG.OPERATION_TYPE = 'INSERT' THEN
					-- Backdate insertion
					DELETE FROM GROUPS WHERE ID = LOG.ID_NEW;
				
				ELSIF LOG.OPERATION_TYPE = 'UPDATE' THEN
					-- Backdate update
					UPDATE GROUPS 
					SET ID = LOG.ID_OLD, NAME = LOG.NAME_OLD
					WHERE ID = LOG.ID_NEW;
				
				ELSIF LOG.OPERATION_TYPE = 'DELETE' THEN
					-- Backdate deletion
					INSERT INTO GROUPS (ID, NAME) VALUES (LOG.ID_OLD, LOG.NAME_OLD);
				
				END IF;
			
			END IF;
			
		END LOOP;
		
		FLAGS.IS_RESTORING_TABLES_BY_LOG := FALSE;
	
	END IF;
	
END;


-- In order to return DB to final state from timestamp log state, we need to reverse all changes as follows:
-- Insert -> Insert
-- Delete -> Delete
-- Update from new to old -> Update from old to new

CREATE OR REPLACE PROCEDURE UNDO_LOGS_JUMP
IS
BEGIN
	DBMS_OUTPUT.PUT_LINE('Inside undoing logs jump procedure!!! ');
	IF NOT FLAGS.IS_JUMPED_TO_TIMESTAMP THEN
		DBMS_OUTPUT.PUT_LINE('DB is already at the final state ');

	ELSE
		DBMS_OUTPUT.PUT_LINE('Undoing jumping to timestamp!!! ' || FLAGS.JUMPED_TIMESTAMP);
	
		FLAGS.IS_RESTORING_TABLES_BY_LOG := TRUE;	
	
		FOR LOG IN ( SELECT * FROM LOGS WHERE LOG_TIMESTAMP >= FLAGS.JUMPED_TIMESTAMP ORDER BY LOG_TIMESTAMP ASC)
		LOOP
			DBMS_OUTPUT.PUT_LINE(' ');
			DBMS_OUTPUT.PUT_LINE('Working on log with id = ' || LOG.ID);
			IF LOG.TABLE_NAME = 'STUDENTS' THEN
				DBMS_OUTPUT.PUT_LINE('Working with STUDENTS record!!! ');

				IF LOG.OPERATION_TYPE = 'INSERT' THEN
					INSERT INTO STUDENTS VALUES (LOG.ID_NEW, LOG.NAME_NEW, LOG.NUMB_FIELD_NEW);
					DBMS_OUTPUT.PUT_LINE('Inserted student with id = ' || LOG.ID_NEW);
				
				ELSIF LOG.OPERATION_TYPE = 'UPDATE' THEN
					-- Backdate update
					UPDATE STUDENTS 
					SET ID = LOG.ID_NEW, NAME = LOG.NAME_NEW, GROUP_ID = LOG.NUMB_FIELD_NEW
					WHERE ID = LOG.ID_OLD;
				
					DBMS_OUTPUT.PUT_LINE('Updated student with id = ' || LOG.ID_OLD);

				
				ELSIF LOG.OPERATION_TYPE = 'DELETE' THEN
					-- Backdate deletion
					DELETE FROM STUDENTS WHERE ID = LOG.ID_OLD;
					DBMS_OUTPUT.PUT_LINE('Deleted student with id = ' || LOG.ID_OLD);
				END IF;
			
			ELSIF LOG.TABLE_NAME = 'GROUPS' THEN
			
				IF LOG.OPERATION_TYPE = 'INSERT' THEN
					-- Backdate insertion
					INSERT INTO GROUPS (ID, NAME) VALUES (LOG.ID_NEW, LOG.NAME_NEW);			
				
				ELSIF LOG.OPERATION_TYPE = 'UPDATE' THEN
					-- Backdate update
					UPDATE GROUPS 
					SET ID = LOG.ID_NEW, NAME = LOG.NAME_NEW
					WHERE ID = LOG.ID_OLD;
				
				ELSIF LOG.OPERATION_TYPE = 'DELETE' THEN
					-- Backdate deletion
					DELETE FROM GROUPS WHERE ID = LOG.ID_OLD;
				
				END IF;
			
			END IF;
			
		END LOOP;
		
		-- Setting table condition timestamp to current system time
		FLAGS.JUMPED_TIMESTAMP := SYSTIMESTAMP;
		
		-- Table condition is restored to final state
		FLAGS.IS_JUMPED_TO_TIMESTAMP := FALSE;

		FLAGS.IS_RESTORING_TABLES_BY_LOG := FALSE;
	
	END IF;
	
END;



BEGIN RESTORE_BY_LOGS(TO_TIMESTAMP('2025-03-09 19:00:00', 'YYYY-MM-DD HH24:MI:SS')); END;

BEGIN UNDO_LOGS_JUMP; END;


SELECT * FROM LOGS ORDER BY LOG_TIMESTAMP ASC;

DELETE FROM LOGS;

SELECT OBJECT_TYPE, OBJECT_NAME, STATUS
FROM USER_OBJECTS
WHERE OBJECT_NAME IN ('LOGS', 'LOGS_ID_SEQ', 'LOGS_ID_TRIGGER', 'RESTORE_BY_LOGS', 'UNDO_LOGS_JUMP')
ORDER BY OBJECT_TYPE, OBJECT_NAME;