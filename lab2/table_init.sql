
--Create tables
	CREATE TABLE STUDENTS (ID NUMBER PRIMARY KEY, NAME VARCHAR2(256) NOT NULL, GROUP_ID NUMBER NOT NULL);

	CREATE TABLE GROUPS(ID NUMBER PRIMARY KEY, NAME VARCHAR2(64) NOT NULL, C_VAL NUMBER NOT NULL);
	
	CREATE INDEX IDX_STUDENTS_GROUP_ID ON STUDENTS(GROUP_ID);

--Create triggers for autoincrementing unique ids
	CREATE SEQUENCE STUDENTS_ID_SEQ
	START WITH 1
	INCREMENT BY 1
	NOCACHE;

	CREATE SEQUENCE GROUPS_ID_SEQ
	START WITH 1
	INCREMENT BY 1
	NOCACHE;
	
--This triggers must provide following features:
--1. Using sequence for providing unique value when id of a new record is not given,
--   iterate through sequence while not find unique id
--2. Check the uniqueness of the id when given on both insert and update operations
--3. Check the uniqueness of the GROUPS.NAME on both insert and update operations
--4. Control if value given to STUDENTS.GROUP_ID exists in GROUPS.ID on insert and update
	
	CREATE OR REPLACE TRIGGER STUDENTS_BEFORE_INSERT
	BEFORE INSERT ON STUDENTS
	FOR EACH ROW
	DECLARE
		NEW_ID NUMBER;
		NEW_ID_IN_TABLE_COUNT NUMBER := 9999;
		GROUPS_WITH_GIVEN_ID NUMBER := 0;	
	
		GROUP_ID_NOT_EXISTS EXCEPTION;
		NOT_UNIQUE_ID EXCEPTION;
	BEGIN
		--Foreign key consistency
		SELECT COUNT(1) INTO GROUPS_WITH_GIVEN_ID FROM GROUPS WHERE GROUPS.ID = :NEW.GROUP_ID;
		IF GROUPS_WITH_GIVEN_ID < 1 THEN
			RAISE GROUP_ID_NOT_EXISTS;
		END IF;
		
		--User can forcefully update record with new ID, in this case it's needed to check
		--Value for sequence for uniqueness
		IF :NEW.ID  IS NULL THEN
			WHILE NEW_ID_IN_TABLE_COUNT > 0
			LOOP
				SELECT STUDENTS_ID_SEQ.NEXTVAL INTO NEW_ID FROM dual;
				SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM STUDENTS WHERE STUDENTS.ID = NEW_ID;
			END LOOP;	
			:NEW.ID := NEW_ID;
				
		--Id is given
		ELSE
			SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM STUDENTS WHERE STUDENTS.ID = :NEW.ID;
			IF NEW_ID_IN_TABLE_COUNT > 0 THEN 
				RAISE NOT_UNIQUE_ID;
			END IF;
		
		END IF;
		
	EXCEPTION
		WHEN GROUP_ID_NOT_EXISTS THEN
 			DBMS_OUTPUT.PUT_LINE('Соответствующей записи ' || :NEW.GROUP_ID || ' в таблице GROUPS не существует');
			RAISE_APPLICATION_ERROR(-20001, 'Соответствующей записи ' || :NEW.GROUP_ID || ' в таблице GROUPS не существует');
		WHEN NOT_UNIQUE_ID THEN
 			DBMS_OUTPUT.PUT_LINE('Первичный ключ ID= ' || :NEW.ID || ' не является уникальным');
			RAISE_APPLICATION_ERROR(-20002, 'Первичный ключ ID= ' || :NEW.ID || ' не является уникальным');
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_BEFORE_UPDATE
	BEFORE UPDATE ON STUDENTS
	FOR EACH ROW 
	DECLARE
		GROUPS_WITH_GIVEN_ID NUMBER := 0;
		NEW_ID_IN_TABLE_COUNT NUMBER := 0;

		GROUP_ID_NOT_EXISTS EXCEPTION;
		NOT_UNIQUE_ID EXCEPTION;
	BEGIN 
		IF :NEW.GROUP_ID != :OLD.GROUP_ID THEN 
			SELECT COUNT(1) INTO GROUPS_WITH_GIVEN_ID FROM GROUPS WHERE GROUPS.ID = :NEW.GROUP_ID;
			IF GROUPS_WITH_GIVEN_ID < 1 THEN
				RAISE GROUP_ID_NOT_EXISTS;
			END IF;
		END IF;
		
		IF :NEW.ID != :OLD.ID THEN
			SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM STUDENTS WHERE STUDENTS.ID = :NEW.ID;
			IF NEW_ID_IN_TABLE_COUNT > 0 THEN 
				RAISE NOT_UNIQUE_ID;
			END IF;
		END IF;
	EXCEPTION
		WHEN GROUP_ID_NOT_EXISTS THEN
 			DBMS_OUTPUT.PUT_LINE('Соответствующей записи ' || :NEW.GROUP_ID || 'в таблице GROUPS не существует');
 			RAISE_APPLICATION_ERROR(-20003, 'Соответствующей записи ' || :NEW.GROUP_ID || 'в таблице GROUPS не существует');		
		WHEN NOT_UNIQUE_ID THEN
 			DBMS_OUTPUT.PUT_LINE('Первичный ключ ID= ' || :NEW.ID || ' не является уникальным');
			RAISE_APPLICATION_ERROR(-20004, 'Первичный ключ ID= ' || :NEW.ID || ' не является уникальным');
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_AFTER_INSERT
	AFTER UPDATE ON STUDENTS
	FOR EACH ROW
	BEGIN 
		UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_AFTER_UPDATE
	AFTER UPDATE ON STUDENTS
	FOR EACH ROW 	
	BEGIN 
		IF :OLD.GROUP_ID != :NEW.GROUP_ID THEN 
			UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :OLD.GROUP_ID;
			UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
		END IF;
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_AFTER_DELETE
	AFTER DELETE ON STUDENTS
	FOR EACH ROW 
	BEGIN 
		UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :NEW.GROUP_ID;
	END;
	
	CREATE OR REPLACE TRIGGER GROUPS_BEFORE_INSERT
	BEFORE INSERT ON GROUPS
	FOR EACH ROW 
	DECLARE 
		GROUPS_WITH_NEW_NAME_COUNT NUMBER := 0;
		NEW_ID NUMBER := 0;
		NEW_ID_IN_TABLE_COUNT NUMBER := 0;
	
		NOT_UNIQUE_GROUP_NAME EXCEPTION;
		NOT_UNIQUE_ID EXCEPTION;
	BEGIN 
		IF :NEW.C_VAL != 0 THEN
 			DBMS_OUTPUT.PUT_LINE('Параметр ' || :NEW.C_VAL || ' принудительно установлен в значение 0');
		END IF;
		:NEW.C_VAL := 0;
		
		SELECT COUNT(1) INTO GROUPS_WITH_NEW_NAME_COUNT FROM GROUPS WHERE NAME = :NEW.NAME;
		IF GROUPS_WITH_NEW_NAME_COUNT > 0 THEN
			RAISE NOT_UNIQUE_GROUP_NAME;
		END IF;
		
		IF :NEW.ID IS NULL THEN
			LOOP
				SELECT GROUPS_ID_SEQ.NEXTVAL INTO NEW_ID FROM DUAL;
				SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM GROUPS WHERE ID = NEW_ID;
				EXIT WHEN NEW_ID_IN_TABLE_COUNT = 0;
			END LOOP;
			:NEW.ID := NEW_ID;
		ELSE
			SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM GROUPS WHERE ID = :NEW.ID;
			IF NEW_ID_IN_TABLE_COUNT > 0 THEN
				RAISE NOT_UNIQUE_ID;
			END IF;
		END IF;
		
	EXCEPTION
		WHEN NOT_UNIQUE_GROUP_NAME THEN
 			DBMS_OUTPUT.PUT_LINE('Группа с именем ' || :NEW.NAME || ' уже существует');
 			RAISE_APPLICATION_ERROR(-20005, 'Группа с именем ' || :NEW.NAME || ' уже существует');
		WHEN NOT_UNIQUE_ID THEN
 			DBMS_OUTPUT.PUT_LINE('Группа с ID= ' || :NEW.ID || ' уже существует');
			RAISE_APPLICATION_ERROR(-20006, 'Группа с ID= ' || :NEW.ID || ' уже существует');
	END;
	
	--Update all connected records in students
	--C_VAL is setted as amount of students by trigger and can't be changed by update
	CREATE OR REPLACE TRIGGER GROUPS_BEFORE_UPDATE
	BEFORE UPDATE ON GROUPS
	FOR EACH ROW 
	DECLARE 
		GROUPS_WITH_NEW_NAME_COUNT NUMBER := 0;
		NEW_ID_IN_TABLE_COUNT NUMBER := 0;

		C_VAL_IS_CHANGED EXCEPTION;
		NOT_UNIQUE_GROUP_NAME EXCEPTION;
		NOT_UNIQUE_ID EXCEPTION;
	BEGIN
		IF :NEW.C_VAL != :OLD.C_VAL THEN
			RAISE C_VAL_IS_CHANGED;
		END IF;
	
		IF :NEW.NAME != :OLD.NAME THEN 
			SELECT COUNT(1) INTO GROUPS_WITH_NEW_NAME_COUNT FROM GROUPS WHERE NAME = :NEW.NAME;
			IF GROUPS_WITH_NEW_NAME_COUNT > 0 THEN
				RAISE NOT_UNIQUE_GROUP_NAME;
			END IF;
		END IF;
	
		IF :NEW.ID != :OLD.ID THEN
			SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM GROUPS WHERE ID = :NEW.ID;
			IF NEW_ID_IN_TABLE_COUNT > 0 THEN
				RAISE NOT_UNIQUE_ID;
			END IF;
		END IF;
		
	EXCEPTION
		WHEN C_VAL_IS_CHANGED THEN
 			DBMS_OUTPUT.PUT_LINE('Параметр C_VAL не может быть изменён вручную');
 			RAISE_APPLICATION_ERROR(-20007, 'C_VAL cant be changed manually');
		WHEN NOT_UNIQUE_GROUP_NAME THEN
 			DBMS_OUTPUT.PUT_LINE('Группа с именем ' || :NEW.NAME || ' уже существует');
 			RAISE_APPLICATION_ERROR(-20008, 'GROUPS record with NAME=' || :NEW.NAME || ' already exists');
		WHEN NOT_UNIQUE_ID THEN
 			DBMS_OUTPUT.PUT_LINE('Группа с ID= ' || :NEW.ID || ' уже существует');
 			RAISE_APPLICATION_ERROR(-20009, 'GROUPS record with ID=' || :NEW.ID || ' already exists');
	END;
		
	
	--STUDENTS must be updated AFTER GROUPS, because this will invoke UPDATE ON STUDENTS trigger, which
	--updates GROUPS records with GROUPS.ID = (:NEW) STUDENTS.GROUP_ID.
	--If STUDENTS updated BEFORE GROUPS, it would cause error, bacause GROUPS.ID did not updated yet
	
	--Also C_VAL must be setted to 0 here, bacause cascading call of after update on student
	--trigges for all connected STUDENTS records will write sum correct C_VAL to 0
	CREATE OR REPLACE TRIGGER GROUPS_AFTER_UPDATE
	AFTER UPDATE ON GROUPS
	FOR EACH ROW
	BEGIN 
		--C_VAL value will be correctly setted by invoked AFTER UPDATE ON STUDENTS triggers
		:NEW.C_VAL := 0;
		--New ID is unique, update connected students
		UPDATE STUDENTS SET GROUP_ID = :NEW.ID WHERE GROUP_ID = :OLD.ID;
	END;
	
	
	CREATE OR REPLACE TRIGGER GROUPS_BEFORE_DELETE
	BEFORE DELETE ON GROUPS
	FOR EACH ROW 
	BEGIN 
		DELETE FROM STUDENTS WHERE GROUP_ID = :OLD.ID; 
	END;
	
	
-- Check objects are created correctly
SELECT OBJECT_TYPE, OBJECT_NAME, STATUS
FROM USER_OBJECTS
WHERE OBJECT_NAME IN ('STUDENTS', 'GROUPS', 'IDX_STUDENTS_GROUP_ID',
'STUDENTS_ID_SEQ', 'GROUPS_ID_SEQ', 'STUDENTS_BEFORE_INSERT', 
'STUDENTS_BEFORE_UPDATE', 'STUDENTS_AFTER_INSERT',
'STUDENTS_AFTER_UPDATE', 'STUDENTS_AFTER_DELETE',
'GROUPS_BEFORE_INSERT', 'GROUPS_BEFORE_UPDATE', 'GROUPS_AFTER_UPDATE',
'GROUPS_BEFORE_DELETE')
AND OBJECT_TYPE IN ('TABLE', 'SEQUENCE', 'TRIGGER', 'INDEX')
ORDER BY OBJECT_TYPE, OBJECT_NAME;
	
	