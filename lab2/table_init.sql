
--Create tables
	CREATE TABLE STUDENTS (ID NUMBER PRIMARY KEY, NAME VARCHAR2(256) NOT NULL, GROUP_ID NUMBER NOT NULL);

	CREATE TABLE GROUPS(ID NUMBER PRIMARY KEY, NAME VARCHAR2(64) NOT NULL, C_VAL NUMBER NOT NULL);

--Create triggers for autoincrementing unique ids
	CREATE SEQUENCE STUDENTS_ID_SEQ
	START WITH 1
	INCREMENT BY 1
	NOCACHE;

	CREATE SEQUENCE GROUPS_ID_SEQ
	START WITH 1
	INCREMENT BY 1
	NOCACHE;
	
--This triggers must provide following features:
--1. Using sequence for providing unique value when id of a new record is not given,
--   iterate through sequence while not find unique id
--2. Check the uniqueness of the id when given on both insert and update operations
--3. Check the uniqueness of the GROUPS.NAME on both insert and update operations
--4. Control if value given to STUDENTS.GROUP_ID exists in GROUPS.ID on insert and update
	
	CREATE OR REPLACE TRIGGER STUDENTS_BEFORE_INSERT
	BEFORE INSERT ON STUDENTS
	FOR EACH ROW
	DECLARE
		NEW_ID NUMBER;
		NEW_ID_IN_TABLE_COUNT NUMBER := 9999;
		GROUPS_WITH_GIVEN_ID NUMBER := 0;	
	
		GROUP_ID_NOT_EXISTS EXCEPTION;
		NOT_UNIQUE_ID EXCEPTION;
	BEGIN
		--Foreign key consistency
		SELECT COUNT(1) INTO GROUPS_WITH_GIVEN_ID FROM GROUPS WHERE GROUPS.ID = :NEW.GROUP_ID;
		IF GROUPS_WITH_GIVEN_ID < 1 THEN
			RAISE GROUP_ID_NOT_EXISTS;
		END IF;
		
		--User can forcefully update record with new ID, in this case it's needed to check
		--Value for sequence for uniqueness
		IF :NEW.ID  IS NULL THEN
			WHILE NEW_ID_IN_TABLE_COUNT > 0
			LOOP
				SELECT STUDENTS_ID_SEQ.NEXTVAL INTO NEW_ID FROM dual;
				SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM STUDENTS WHERE STUDENTS.ID = NEW_ID;
			END LOOP;	
			:NEW.ID := NEW_ID;
				
		--Id is given
		ELSE
			SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM STUDENTS WHERE STUDENTS.ID = :NEW.ID;
			IF NEW_ID_IN_TABLE_COUNT > 0 THEN 
				RAISE NOT_UNIQUE_ID;
			END IF;
		
		END IF;
		
	EXCEPTION
		WHEN GROUP_ID_NOT_EXISTS THEN
 			DBMS_OUTPUT.PUT_LINE('Соответствующей записи ' || :NEW.GROUP_ID || 'в таблице GROUPS не существует');
		WHEN NOT_UNIQUE_ID THEN
 			DBMS_OUTPUT.PUT_LINE('Первичный ключ ID= ' || :NEW.ID || ' не является уникальным');
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_BEFORE_UPDATE
	BEFORE UPDATE ON STUDENTS
	FOR EACH ROW 
	DECLARE
		GROUPS_WITH_GIVEN_ID NUMBER := 0;
		NEW_ID_IN_TABLE_COUNT NUMBER := 0;

		GROUP_ID_NOT_EXISTS EXCEPTION;
		NOT_UNIQUE_ID EXCEPTION;
	BEGIN 
		IF :NEW.GROUP_ID != :OLD.GROUP_ID THEN 
			SELECT COUNT(1) INTO GROUPS_WITH_GIVEN_ID FROM GROUPS WHERE GROUPS.ID = :NEW.GROUP_ID;
			IF GROUPS_WITH_GIVEN_ID < 1 THEN
				RAISE GROUP_ID_NOT_EXISTS;
			END IF;
		END IF;
		
		IF :NEW.ID != :OLD.ID THEN
			SELECT COUNT(1) INTO NEW_ID_IN_TABLE_COUNT FROM STUDENTS WHERE STUDENTS.ID = :NEW.ID;
			IF NEW_ID_IN_TABLE_COUNT > 0 THEN 
				RAISE NOT_UNIQUE_ID;
			END IF;
		END IF;
	EXCEPTION
		WHEN GROUP_ID_NOT_EXISTS THEN
 			DBMS_OUTPUT.PUT_LINE('Соответствующей записи ' || :NEW.GROUP_ID || 'в таблице GROUPS не существует');
		WHEN NOT_UNIQUE_ID THEN
 			DBMS_OUTPUT.PUT_LINE('Первичный ключ ID= ' || :NEW.ID || ' не является уникальным');
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_AFTER_INSERT
	AFTER UPDATE ON STUDENTS
	FOR EACH ROW
	BEGIN 
		UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_AFTER_UPDATE
	AFTER UPDATE ON STUDENTS
	FOR EACH ROW 	
	BEGIN 
		IF :OLD.GROUP_ID != :NEW.GROUP_ID THEN 
			UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :OLD.GROUP_ID;
			UPDATE GROUPS SET C_VAL = C_VAL + 1 WHERE ID = :NEW.GROUP_ID;
		END IF;
	END;
	
	CREATE OR REPLACE TRIGGER STUDENTS_AFTER_DELETE
	AFTER DELETE ON STUDENTS
	FOR EACH ROW 
	BEGIN 
		UPDATE GROUPS SET C_VAL = C_VAL - 1 WHERE ID = :NEW.GROUP_ID;
	END;
	
	CREATE OR REPLACE TRIGGER GROUPS_BEFORE_INSERT
	BEFORE INSERT ON GROUPS
	FOR EACH ROW 
	BEGIN 
		
	END;
	
	--updage all connected records in students?
	CREATE OR REPLACE TRIGGER GROUPS_BEFORE_UPDATE
	BEFORE UPDATE ON GROUPS
	FOR EACH ROW 
	BEGIN 
		
	END;
	
	CREATE OR REPLACE TRIGGER GROUPS_BEFORE_DELETE
	BEFORE DELETE ON GROUPS
	FOR EACH ROW 
	BEGIN 
		
	END;
	
	
-- Check objects are created correctly
SELECT OBJECT_TYPE, OBJECT_NAME, STATUS
FROM USER_OBJECTS
WHERE OBJECT_NAME IN ('STUDENTS', 'GROUPS', 'STUDENTS_ID_SEQ', 'GROUPS_ID_SEQ', 
'STUDENTS_BEFORE_INSERT', 'STUDENTS_BEFORE_UPDATE', 'STUDENTS_AFTER_INSERT',
'STUDENTS_AFTER_UPDATE', 'STUDENTS_AFTER_DELETE')
AND OBJECT_TYPE IN ('TABLE', 'SEQUENCE', 'TRIGGER')
ORDER BY OBJECT_TYPE;
	
	